Assignment: GS 540 HW9
Name: Vincent Chau
Email: vkchau@uw.edu
Language: C++17
Runtime: 0m0.542s

State Histogram:
1=221617
2=54130

Segment Histogram:
1=912
2=911

Initial State Probabilities:
1=0.95000
2=0.05000

Transition Probabilities:
1,1=0.95000
1,2=0.05000
2,1=0.10000
2,2=0.90000

Emission Probabilities:
1,A--=0.00059
1,A-A=0.01146
1,A-C=0.00086
1,A-G=0.00235
1,A-T=0.00085
1,AA-=0.00412
1,AAA=0.15403
1,AAC=0.00725
1,AAG=0.02133
1,AAT=0.00633
1,AC-=0.00045
1,ACA=0.01285
1,ACC=0.00270
1,ACG=0.00253
1,ACT=0.00150
1,AG-=0.00111
1,AGA=0.03189
1,AGC=0.00211
1,AGG=0.01328
1,AGT=0.00198
1,AT-=0.00049
1,ATA=0.01318
1,ATC=0.00171
1,ATG=0.00280
1,ATT=0.00333
1,C--=0.00036
1,C-A=0.00072
1,C-C=0.00699
1,C-G=0.00058
1,C-T=0.00210
1,CA-=0.00036
1,CAA=0.00335
1,CAC=0.00864
1,CAG=0.00132
1,CAT=0.00263
1,CC-=0.00233
1,CCA=0.00417
1,CCC=0.08468
1,CCG=0.00379
1,CCT=0.01749
1,CG-=0.00028
1,CGA=0.00127
1,CGC=0.00689
1,CGG=0.00203
1,CGT=0.00216
1,CT-=0.00101
1,CTA=0.00203
1,CTC=0.02829
1,CTG=0.00181
1,CTT=0.01342
1,G--=0.00035
1,G-A=0.00211
1,G-C=0.00059
1,G-G=0.00698
1,G-T=0.00072
1,GA-=0.00099
1,GAA=0.01338
1,GAC=0.00181
1,GAG=0.02824
1,GAT=0.00203
1,GC-=0.00028
1,GCA=0.00216
1,GCC=0.00202
1,GCG=0.00687
1,GCT=0.00127
1,GG-=0.00231
1,GGA=0.01747
1,GGC=0.00380
1,GGG=0.08460
1,GGT=0.00417
1,GT-=0.00036
1,GTA=0.00262
1,GTC=0.00132
1,GTG=0.00865
1,GTT=0.00335
1,T--=0.00057
1,T-A=0.00084
1,T-C=0.00235
1,T-G=0.00086
1,T-T=0.01149
1,TA-=0.00049
1,TAA=0.00332
1,TAC=0.00282
1,TAG=0.00171
1,TAT=0.01320
1,TC-=0.00111
1,TCA=0.00198
1,TCC=0.01328
1,TCG=0.00211
1,TCT=0.03190
1,TG-=0.00045
1,TGA=0.00150
1,TGC=0.00252
1,TGG=0.00271
1,TGT=0.01285
1,TT-=0.00409
1,TTA=0.00635
1,TTC=0.02137
1,TTG=0.00726
1,TTT=0.15465
2,A--=0.00012
2,A-A=0.00058
2,A-C=0.00005
2,A-G=0.00013
2,A-T=0.00003
2,AA-=0.00030
2,AAA=0.22082
2,AAC=0.00198
2,AAG=0.00524
2,AAT=0.00101
2,AC-=0.00003
2,ACA=0.00309
2,ACC=0.00113
2,ACG=0.00048
2,ACT=0.00021
2,AG-=0.00007
2,AGA=0.00761
2,AGC=0.00041
2,AGG=0.00469
2,AGT=0.00025
2,AT-=0.00003
2,ATA=0.00203
2,ATC=0.00027
2,ATG=0.00041
2,ATT=0.00069
2,C--=0.00016
2,C-A=0.00004
2,C-C=0.00076
2,C-G=0.00006
2,C-T=0.00011
2,CA-=0.00003
2,CAA=0.00112
2,CAC=0.00316
2,CAG=0.00036
2,CAT=0.00035
2,CC-=0.00039
2,CCA=0.00142
2,CCC=0.21487
2,CCG=0.00191
2,CCT=0.00527
2,CG-=0.00004
2,CGA=0.00028
2,CGC=0.00301
2,CGG=0.00123
2,CGT=0.00042
2,CT-=0.00009
2,CTA=0.00028
2,CTC=0.00917
2,CTG=0.00043
2,CTT=0.00352
2,G--=0.00016
2,G-A=0.00011
2,G-C=0.00006
2,G-G=0.00076
2,G-T=0.00004
2,GA-=0.00009
2,GAA=0.00351
2,GAC=0.00043
2,GAG=0.00914
2,GAT=0.00029
2,GC-=0.00004
2,GCA=0.00041
2,GCC=0.00123
2,GCG=0.00301
2,GCT=0.00028
2,GG-=0.00038
2,GGA=0.00525
2,GGC=0.00190
2,GGG=0.21461
2,GGT=0.00142
2,GT-=0.00003
2,GTA=0.00035
2,GTC=0.00034
2,GTG=0.00315
2,GTT=0.00110
2,T--=0.00013
2,T-A=0.00003
2,T-C=0.00014
2,T-G=0.00005
2,T-T=0.00059
2,TA-=0.00003
2,TAA=0.00069
2,TAC=0.00040
2,TAG=0.00026
2,TAT=0.00202
2,TC-=0.00007
2,TCA=0.00024
2,TCC=0.00475
2,TCG=0.00041
2,TCT=0.00764
2,TG-=0.00003
2,TGA=0.00022
2,TGC=0.00047
2,TGG=0.00113
2,TGT=0.00304
2,TT-=0.00031
2,TTA=0.00102
2,TTC=0.00520
2,TTG=0.00199
2,TTT=0.22090

Longest Segment List:

27106783 27108023
27149114 27150259
27170930 27171941
27116222 27117125
27108299 27109088
27190694 27191482
27189995 27190665
27153545 27154205
27180046 27180696
26934893 26935504

Annotations:

Start: 27106783
End: 27108023
Overlaps with exons of the HOXA2 gene

Start: 27149114
End: 27150259
Overlaps with exons of the HOXA5 gene

Start: 27170930
End: 27171941
Overlaps with exons of the HOXA9 gene

Start: 27116222
End: 27117125
Overlaps with exons of the HOXA3 gene

Start: 27108299
End: 27109088
Overlaps with exons of the HOXA2 gene


Program:

#include <bits/stdc++.h>

using namespace std;

struct Aln {
    int start;
    int end;
    string human;
    string dog;
    string mouse;
};

int main() {
    ios::sync_with_stdio(false);
    cin.tie(NULL);

    freopen("output.txt", "w", stdout);
    // string input = "input/ENm006_short.aln";
    string input = "input/ENm010.aln";
    string input_neu = "input/STATE1_anc_rep_counts.txt";
    string input_con = "input/STATE2_codon1_2_counts.txt";
    freopen(input.c_str(), "r", stdin);

    vector<Aln> alns;
    string line;
    while (getline(cin, line)) {
        if (line.front() == '#') {
            int d_a = line.find(':');
            int d_b = line.find('-');
            alns.push_back({stoi(line.substr(d_a + 1, d_b - d_a)),
                            stoi(line.substr(d_b + 1))});
        } else if (line.find("hg18") != -1) {
            alns.back().human = line.substr(line.find('\t') + 1);
        } else if (line.find("canFam2") != -1) {
            alns.back().dog = line.substr(line.find('\t') + 1);
        } else if (line.find("mm9") != -1) {
            alns.back().mouse = line.substr(line.find('\t') + 1);
        }
    }

    cin.clear();
    freopen(input_neu.c_str(), "r", stdin);

    map<string, int> counts_1;
    while (getline(cin, line)) {
        stringstream linestream(line);
        string seq;
        string val;
        linestream >> seq;
        linestream >> val;
        counts_1[seq] = stoi(val);
    }

    cin.clear();
    freopen(input_con.c_str(), "r", stdin);

    map<string, int> counts_2;
    while (getline(cin, line)) {
        stringstream linestream(line);
        string seq;
        string val;
        linestream >> seq;
        linestream >> val;
        counts_2[seq] = stoi(val);
    }

    int tot_1 = accumulate(
        counts_1.begin(), counts_1.end(), 0,
        [](const int prev, const auto& v) { return prev + v.second; });
    int tot_2 = accumulate(
        counts_2.begin(), counts_2.end(), 0,
        [](const int prev, const auto& v) { return prev + v.second; });
    map<string, double> e_1;
    for (auto& [k, v] : counts_1) {
        e_1[k] = static_cast<double>(v) / tot_1;
    }
    map<string, double> e_2;
    for (auto& [k, v] : counts_2) {
        e_2[k] = static_cast<double>(v) / tot_2;
    }

    // State 1
    double init_1 = 0.95;
    double a_11 = 0.95;
    double a_12 = 0.05;

    // State 2
    double init_2 = 0.05;
    double a_21 = 0.10;
    double a_22 = 0.90;

    string human;
    string dog;
    string mouse;
    for (auto& a : alns) {
        human += a.human;
        dog += a.dog;
        mouse += a.mouse;
    }

    vector<string> seqs;
    for (int i = 0; i < human.length(); i++) {
        string seq;
        seq += human.at(i);
        seq += dog.at(i);
        seq += mouse.at(i);
        seqs.push_back(seq);
    }

    vector<double> dp_1(seqs.size());
    vector<int> back_1(seqs.size());
    vector<double> dp_2(seqs.size());
    vector<int> back_2(seqs.size());

    // Initialization Case
    // "Transition" and Emission
    double curr_1 = log(init_1) + log(e_1.at(seqs[0]));
    double curr_2 = log(init_2) + log(e_2.at(seqs[0]));
    // DP
    int prev_1 = -1;
    int prev_2 = -1;
    dp_1[0] = curr_1;
    dp_2[0] = curr_2;

    for (int i = 1; i < seqs.size(); i++) {
        // Transition and Emission
        double h_11 = dp_1[i - 1] + log(a_11) + log(e_1.at(seqs[i]));
        double h_21 = dp_2[i - 1] + log(a_21) + log(e_1.at(seqs[i]));
        double h_12 = dp_1[i - 1] + log(a_12) + log(e_2.at(seqs[i]));
        double h_22 = dp_2[i - 1] + log(a_22) + log(e_2.at(seqs[i]));
        if (h_11 > h_21) {
            prev_1 = 1;
            curr_1 = h_11;
        } else {
            prev_1 = 2;
            curr_1 = h_21;
        }
        if (h_12 > h_22) {
            prev_2 = 1;
            curr_2 = h_12;
        } else {
            prev_2 = 2;
            curr_2 = h_22;
        }
        // DP
        dp_1[i] = curr_1;
        back_1[i - 1] = prev_1;
        dp_2[i] = curr_2;
        back_2[i - 1] = prev_2;
    }
    back_1[back_1.size() - 1] = 1;
    back_2[back_2.size() - 1] = 2;

    vector<int> viterbi;
    vector<int>* back;
    if (dp_1.back() > dp_2.back()) {
        back = &back_1;
    } else {
        back = &back_2;
    }
    for (int i = back->size() - 1; i >= 0; i--) {
        viterbi.push_back(back->at(i));
        if (back->at(i) == 1) {
            back = &back_1;
        } else {
            back = &back_2;
        }
    }
    reverse(viterbi.begin(), viterbi.end());

    vector<pair<int, int>> segList_1;
    vector<pair<int, int>> segList_2;

    int v_start = alns[0].start;
    int offset = 0;
    int prev = -1;

    map<int, int> s;
    for (int i = 0; i < viterbi.size(); i++) {
        s[viterbi[i]]++;
        if (viterbi[i] != prev && i != 0) {
            if (prev == 1) {
                segList_1.push_back({v_start + offset, v_start + i - 1});
            } else if (prev == 2) {
                segList_2.push_back({v_start + offset, v_start + i - 1});
            }
            offset = i;
        }
        prev = viterbi[i];
    }
    if (prev == 1) {
        segList_1.push_back({v_start + offset, v_start + viterbi.size() - 1});
    } else if (prev == 2) {
        segList_2.push_back({v_start + offset, v_start + viterbi.size() - 1});
    }

    sort(segList_2.begin(), segList_2.end(), [](const auto& a, const auto& b) {
        return (a.second - a.first) > (b.second - b.first);
    });

    cout << "State Histogram:" << '\n';
    for (auto& [k, v] : s) {
        cout << k << '=' << v << '\n';
    }
    cout << '\n';
    cout << "Segment Histogram:" << '\n';
    cout << "1=" << segList_1.size() << '\n';
    cout << "2=" << segList_2.size() << '\n';
    cout << '\n';
    cout << fixed << setprecision(5);
    cout << "Initial State Probabilities:" << '\n';
    cout << "1=" << init_1 << '\n';
    cout << "2=" << init_2 << '\n';
    cout << '\n';
    cout << "Transition Probabilities:" << '\n';
    cout << "1,1=" << a_11 << '\n';
    cout << "1,2=" << a_12 << '\n';
    cout << "2,1=" << a_21 << '\n';
    cout << "2,2=" << a_22 << '\n';
    cout << '\n';
    cout << "Emission Probabilities:" << '\n';
    for (auto& [k, v] : e_1) {
        cout << "1," << k << '=' << v << '\n';
    }
    for (auto& [k, v] : e_2) {
        cout << "2," << k << '=' << v << '\n';
    }
    cout << '\n';
    cout << "Longest Segment List:" << '\n';
    cout << '\n';
    for (int i = 0; i < 10; i++) {
        cout << segList_2[i].first << ' ' << segList_2[i].second << '\n';
    }
    cout << '\n';
    cout << "Annotations:" << '\n';
    cout << '\n';
    for (int i = 0; i < 5; i++) {
        cout << "Start: " << segList_2[i].first << '\n';
        cout << "End: " << segList_2[i].second << '\n';
        cout << '\n';
        cout << '\n';
    }
    cout << '\n';

    return 0;
}